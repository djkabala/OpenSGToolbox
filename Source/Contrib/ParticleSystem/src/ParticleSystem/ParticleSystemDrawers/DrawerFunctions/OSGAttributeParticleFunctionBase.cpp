/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact:  David Kabala, Dan Guilliams (djkabala/dan.guilliams@gmail.com)*
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class AttributeParticleFunction!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"




#include "OSGAttributeParticleFunctionBase.h"
#include "OSGAttributeParticleFunction.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::AttributeParticleFunction
    
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var std::string     AttributeParticleFunctionBase::_sfAttribute
    The attribute that the function will use to determine the index.
*/

/*! \var Int32           AttributeParticleFunctionBase::_sfSequenceOrder
    The order in which to use images.
    DIRECT: The value of the mapped attribute is used as the index of the sequence.
    CUSTOM: The value of the mapped attribute is used to as the index of the custom sequence.
    (e.g., if the mapped value is 4, the 4th value in the custom sequence will be
    used for the sequence index).
*/

/*! \var UInt32          AttributeParticleFunctionBase::_mfCustomSequence
    Used to specify the sequence in which the individual sprites should be 
    drawn in. Any value greater than the number of available sprites will be
    "wrapped around".  For example, if there are 4 sprites in the sequence, 
    and a value in CustomSequence is 6, then the 2nd sprite will be used.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<AttributeParticleFunction *>::_type("AttributeParticleFunctionPtr", "ParticleFunctionPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(AttributeParticleFunction *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           AttributeParticleFunction *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           AttributeParticleFunction *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void AttributeParticleFunctionBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFString::Description(
        SFString::getClassType(),
        "Attribute",
        "The attribute that the function will use to determine the index.\n",
        AttributeFieldId, AttributeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&AttributeParticleFunction::editHandleAttribute),
        static_cast<FieldGetMethodSig >(&AttributeParticleFunction::getHandleAttribute));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "SequenceOrder",
        "The order in which to use images.\n"
        "DIRECT: The value of the mapped attribute is used as the index of the sequence.\n"
        "CUSTOM: The value of the mapped attribute is used to as the index of the custom sequence.\n"
        "(e.g., if the mapped value is 4, the 4th value in the custom sequence will be\n"
        "used for the sequence index).\n",
        SequenceOrderFieldId, SequenceOrderFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&AttributeParticleFunction::editHandleSequenceOrder),
        static_cast<FieldGetMethodSig >(&AttributeParticleFunction::getHandleSequenceOrder));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt32::Description(
        MFUInt32::getClassType(),
        "CustomSequence",
        "Used to specify the sequence in which the individual sprites should be \n"
        "drawn in. Any value greater than the number of available sprites will be\n"
        "\"wrapped around\".  For example, if there are 4 sprites in the sequence, \n"
        "and a value in CustomSequence is 6, then the 2nd sprite will be used.\n",
        CustomSequenceFieldId, CustomSequenceFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&AttributeParticleFunction::editHandleCustomSequence),
        static_cast<FieldGetMethodSig >(&AttributeParticleFunction::getHandleCustomSequence));

    oType.addInitialDesc(pDesc);
}


AttributeParticleFunctionBase::TypeObject AttributeParticleFunctionBase::_type(
    AttributeParticleFunctionBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&AttributeParticleFunctionBase::createEmptyLocal),
    AttributeParticleFunction::initMethod,
    AttributeParticleFunction::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&AttributeParticleFunction::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"AttributeParticleFunction\"\n"
    "    parent=\"ParticleFunction\"\n"
    "    library=\"ContribParticleSystem\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    authors=\"David Kabala, Dan Guilliams (djkabala/dan.guilliams@gmail.com)\"\n"
    ">\n"
    "\t<Field\n"
    "\t\tname=\"Attribute\"\n"
    "\t\ttype=\"std::string\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe attribute that the function will use to determine the index.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"SequenceOrder\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"AttributeParticleFunction::DIRECT\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe order in which to use images.\n"
    "\tDIRECT: The value of the mapped attribute is used as the index of the sequence.\n"
    "\tCUSTOM: The value of the mapped attribute is used to as the index of the custom sequence.\n"
    "\t\t(e.g., if the mapped value is 4, the 4th value in the custom sequence will be\n"
    "\t\tused for the sequence index).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"CustomSequence\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tUsed to specify the sequence in which the individual sprites should be \n"
    "\tdrawn in. Any value greater than the number of available sprites will be\n"
    "\t\"wrapped around\".  For example, if there are 4 sprites in the sequence, \n"
    "\tand a value in CustomSequence is 6, then the 2nd sprite will be used.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &AttributeParticleFunctionBase::getType(void)
{
    return _type;
}

const FieldContainerType &AttributeParticleFunctionBase::getType(void) const
{
    return _type;
}

UInt32 AttributeParticleFunctionBase::getContainerSize(void) const
{
    return sizeof(AttributeParticleFunction);
}

/*------------------------- decorator get ------------------------------*/


SFString *AttributeParticleFunctionBase::editSFAttribute(void)
{
    editSField(AttributeFieldMask);

    return &_sfAttribute;
}

const SFString *AttributeParticleFunctionBase::getSFAttribute(void) const
{
    return &_sfAttribute;
}


SFInt32 *AttributeParticleFunctionBase::editSFSequenceOrder(void)
{
    editSField(SequenceOrderFieldMask);

    return &_sfSequenceOrder;
}

const SFInt32 *AttributeParticleFunctionBase::getSFSequenceOrder(void) const
{
    return &_sfSequenceOrder;
}


MFUInt32 *AttributeParticleFunctionBase::editMFCustomSequence(void)
{
    editMField(CustomSequenceFieldMask, _mfCustomSequence);

    return &_mfCustomSequence;
}

const MFUInt32 *AttributeParticleFunctionBase::getMFCustomSequence(void) const
{
    return &_mfCustomSequence;
}






/*------------------------------ access -----------------------------------*/

UInt32 AttributeParticleFunctionBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (AttributeFieldMask & whichField))
    {
        returnValue += _sfAttribute.getBinSize();
    }
    if(FieldBits::NoField != (SequenceOrderFieldMask & whichField))
    {
        returnValue += _sfSequenceOrder.getBinSize();
    }
    if(FieldBits::NoField != (CustomSequenceFieldMask & whichField))
    {
        returnValue += _mfCustomSequence.getBinSize();
    }

    return returnValue;
}

void AttributeParticleFunctionBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (AttributeFieldMask & whichField))
    {
        _sfAttribute.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SequenceOrderFieldMask & whichField))
    {
        _sfSequenceOrder.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CustomSequenceFieldMask & whichField))
    {
        _mfCustomSequence.copyToBin(pMem);
    }
}

void AttributeParticleFunctionBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (AttributeFieldMask & whichField))
    {
        _sfAttribute.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SequenceOrderFieldMask & whichField))
    {
        _sfSequenceOrder.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CustomSequenceFieldMask & whichField))
    {
        _mfCustomSequence.copyFromBin(pMem);
    }
}

//! create a new instance of the class
AttributeParticleFunctionTransitPtr AttributeParticleFunctionBase::createLocal(BitVector bFlags)
{
    AttributeParticleFunctionTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<AttributeParticleFunction>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
AttributeParticleFunctionTransitPtr AttributeParticleFunctionBase::createDependent(BitVector bFlags)
{
    AttributeParticleFunctionTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<AttributeParticleFunction>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
AttributeParticleFunctionTransitPtr AttributeParticleFunctionBase::create(void)
{
    AttributeParticleFunctionTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<AttributeParticleFunction>(tmpPtr);
    }

    return fc;
}

AttributeParticleFunction *AttributeParticleFunctionBase::createEmptyLocal(BitVector bFlags)
{
    AttributeParticleFunction *returnValue;

    newPtr<AttributeParticleFunction>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
AttributeParticleFunction *AttributeParticleFunctionBase::createEmpty(void)
{
    AttributeParticleFunction *returnValue;

    newPtr<AttributeParticleFunction>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr AttributeParticleFunctionBase::shallowCopyLocal(
    BitVector bFlags) const
{
    AttributeParticleFunction *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const AttributeParticleFunction *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr AttributeParticleFunctionBase::shallowCopyDependent(
    BitVector bFlags) const
{
    AttributeParticleFunction *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const AttributeParticleFunction *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr AttributeParticleFunctionBase::shallowCopy(void) const
{
    AttributeParticleFunction *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const AttributeParticleFunction *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

AttributeParticleFunctionBase::AttributeParticleFunctionBase(void) :
    Inherited(),
    _sfAttribute              (),
    _sfSequenceOrder          (Int32(AttributeParticleFunction::DIRECT)),
    _mfCustomSequence         ()
{
}

AttributeParticleFunctionBase::AttributeParticleFunctionBase(const AttributeParticleFunctionBase &source) :
    Inherited(source),
    _sfAttribute              (source._sfAttribute              ),
    _sfSequenceOrder          (source._sfSequenceOrder          ),
    _mfCustomSequence         (source._mfCustomSequence         )
{
}


/*-------------------------- destructors ----------------------------------*/

AttributeParticleFunctionBase::~AttributeParticleFunctionBase(void)
{
}


GetFieldHandlePtr AttributeParticleFunctionBase::getHandleAttribute       (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfAttribute,
             this->getType().getFieldDesc(AttributeFieldId),
             const_cast<AttributeParticleFunctionBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AttributeParticleFunctionBase::editHandleAttribute      (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfAttribute,
             this->getType().getFieldDesc(AttributeFieldId),
             this));


    editSField(AttributeFieldMask);

    return returnValue;
}

GetFieldHandlePtr AttributeParticleFunctionBase::getHandleSequenceOrder   (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSequenceOrder,
             this->getType().getFieldDesc(SequenceOrderFieldId),
             const_cast<AttributeParticleFunctionBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AttributeParticleFunctionBase::editHandleSequenceOrder  (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSequenceOrder,
             this->getType().getFieldDesc(SequenceOrderFieldId),
             this));


    editSField(SequenceOrderFieldMask);

    return returnValue;
}

GetFieldHandlePtr AttributeParticleFunctionBase::getHandleCustomSequence  (void) const
{
    MFUInt32::GetHandlePtr returnValue(
        new  MFUInt32::GetHandle(
             &_mfCustomSequence,
             this->getType().getFieldDesc(CustomSequenceFieldId),
             const_cast<AttributeParticleFunctionBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AttributeParticleFunctionBase::editHandleCustomSequence (void)
{
    MFUInt32::EditHandlePtr returnValue(
        new  MFUInt32::EditHandle(
             &_mfCustomSequence,
             this->getType().getFieldDesc(CustomSequenceFieldId),
             this));


    editMField(CustomSequenceFieldMask, _mfCustomSequence);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void AttributeParticleFunctionBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    AttributeParticleFunction *pThis = static_cast<AttributeParticleFunction *>(this);

    pThis->execSync(static_cast<AttributeParticleFunction *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *AttributeParticleFunctionBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    AttributeParticleFunction *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const AttributeParticleFunction *>(pRefAspect),
                  dynamic_cast<const AttributeParticleFunction *>(this));

    return returnValue;
}
#endif

void AttributeParticleFunctionBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfCustomSequence.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
